/*
 The C++ Programming Language, 4th Edition
 */

int main()
{
    /**
     * Language Features

        [1] Uniform and general initialization using {}-lists (§2.2.2, §6.3.5)
        [2] Type deduction from initializer: auto (§2.2.2, §6.3.6.1)
        [3] Prevention of narrowing (§2.2.2, §6.3.5)
        [4] Generalized and guaranteed constant expressions: constexpr (§2.2.3, §10.4, §12.1.6)
        [5] Range-for-statement (§2.2.5, §9.5.1)
        [6] Null pointer keyword: nullptr (§2.2.5, §7.2.2)
        [7] Scoped and strongly typed enums : enum class (§2.3.3, §8.4.1)
        [8] Compile-time assertions: static_assert (§2.4.3.3, §24.4)
        [9] Language mapping of {}-list to std::initializer_list (§3.2.1.3, §17.3.4)
        [10] Rvalue references (enabling move semantics; §3.3.2, §7.7.2)
        [11] Nested template arguments ending with >> (no space between the > s; §3.4.1)
        [12] Lambdas (§3.4.3, §11.4)
        [13] Variadic templates (§3.4.4, §28.6)
        [14] Type and template aliases (§3.4.5, §6.5, §23.6)
        [15] Unicode characters (§6.2.3.2, §7.3.2.2)
        [16] long long integer type (§6.2.4)
        [17] Alignment controls: alignas and alignof (§6.2.9)
        [18] The ability to use the type of an expression as a type in a declaration: decltype (§6.3.6.1)
        [19] Raw string literals (§7.3.2.1)
        [20] Generalized POD (§8.2.6)
        [21] Generalized union s (§8.3.1)
        [22] Local classes as template arguments (§11.4.2, §25.2.1)
        [23] Suffix return type syntax (§12.1.4)
        [24] A syntax for attributes and two standard attributes: [[carries_dependency]] (§41.3) and [[noreturn]]
     (§12.1.7) [25] Preventing exception propagation: the noexcept specifier (§13.5.1.1)
     */

    /**
     * Standard_Library Components

        [1] initializer_list constructors for containers (§3.2.1.3, §17.3.4, §31.3.2)
        [2] Move semantics for containers (§3.3.1, §17.5.2, §31.3.2)
        [3] A singly-linked list: forward_list (§4.4.5, §31.4.2)
        [4] Hash containers: unordered_map, unordered_multimap, unordered_set, and unordered_multiset (§4.4.5, §31.4.3)
        [5] Resource management pointers: unique_ptr, shared_ptr, and weak_ptr (§5.2.1, §34.3)
        [6] Concurrency support: thread (§5.3.1, §42.2), mutexes (§5.3.4, §42.3.1), locks (§5.3.4, §42.3.2), and
     condition variables (§5.3.4.1, §42.3.4) [7] Higher-level concurrency support: packaged_thread, future, promise, and
     async() (§5.3.5, §42.4) [8] tuple s (§5.4.3, §28.5, §34.2.4.2) [9] Regular expressions: regex (§5.5, Chapter 37)
        [10] Random numbers: uniform_int_distribution, normal_distribution, random_engine, etc. (§5.6.3, §40.7)
        [11] Integer type names, such as int16_t, uint32_t, and int_fast64_t (§6.2.8, §43.7)
        [12] A fixed-sized contiguous sequence container: array (§8.2.4, §34.2.1)
        [13] Copying and rethrowing exceptions (§30.4.1.2)
        [14] Error reporting using error codes: system_error (§30.4.3)
        [15] emplace() operations for containers (§31.3.6)
        [16] Wide use of constexpr functions
        [17] Systematic use of noexcept functions
        [18] Improved function adaptors: function and bind() (§33.5)
        [19] string to numeric value conversions (§36.3.5)
        [20] Scoped allocators (§34.4.4)
        [21] Type traits, such as is_integral and is_base_of (§35.4)
        [22] Time utilities: duration and time_point (§35.2)
        [23] Compile-time rational arithmetic: ratio (§35.3)
        [24] Abandoning a process: quick_exit (§15.4.3)
        [25] More algorithms, such as move(), copy_if(), and is_sorted() (Chapter 32)
        [26] Garbage collection ABI (§34.5)
        [27] Low-level concurrency support: atomics (§41.3)
     */
}
